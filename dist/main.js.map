{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://yfm/./linklist/LinkedList.js","webpack://yfm/./linklist/linked-list-nodes.js","webpack://yfm/./util/defaultEquals.js","webpack://yfm/webpack/bootstrap","webpack://yfm/webpack/runtime/define property getters","webpack://yfm/webpack/runtime/hasOwnProperty shorthand","webpack://yfm/webpack/runtime/make namespace object","webpack://yfm/./src/index.js"],"sourcesContent":["import { defaultEquals } from \"../util/defaultEquals\"\r\nimport { Node } from \"./linked-list-nodes\"\r\n\r\nexport class LinkedList {\r\n\r\n    constructor(equalsFn = defaultEquals) { // ES6的默认参数\r\n        this.count = 0  \r\n        this.head = undefined  // 链表的结构容器就是一个头指针 , 用null也可以\r\n        this.equalsFn = equalsFn\r\n    }\r\n   \r\n    //  三个判断:\r\n    //        ①当操作需要传入索引时,首先判断索引是否越界(index >= 0 && index < index < this.count)\r\n    //        ② 链表是否为空 head === null   count === 0  (index < count 说明count不为0) ;链表为空直接结束操作(除了addion)\r\n    //           ③ 若有元素：是否处理head结点;处理head结点时考虑是否单元素的差异(能处理非结点隐式说明了链表非单元素)\r\n   \r\n      \r\n     // 两种遍历: ①while遍历 ②索引遍历\r\n\r\n     //  简写优化： 找逻辑重复\r\n    push(element) {\r\n        const node = new Node(element) // JS的class用法跟构造函数一样\r\n        let current\r\n        if(this.head == null) {  // 这里改成用=== 就不等了\r\n            this.head = node \r\n        } else {\r\n            current =  this.head // current指向头,准备开始用current遍历到末节点\r\n            while (current.next != null) {\r\n                current = current.next\r\n            }\r\n            current.next = node\r\n        }\r\n        this.count++\r\n    }\r\n    \r\n    \r\n    removeAt (index) {\r\n        if (index >= 0 && index < this.count) { // index < this.count除了限制越界外 \r\n            // 还限制了链表本身为空的情况 , 因为链表空了的话count ====0 , index能小于count说明count不能是0\r\n            let current = this.head\r\n          \r\n            if(index===0) { // 删除首元素\r\n                if (this.count == 1 ){\r\n                    this.head = null\r\n                }else {\r\n                    this.head = this.head.next\r\n                }\r\n                // return head.element // 多余\r\n                // 40-44 可合并为 this.head = current.next \r\n            }else{\r\n                let previous // 链表删除的本质是'跨过',既然要跨过，找到index本身还不够,还要记录index前一个结点 \r\n\r\n                for (let i = 0 ; i < index ; i++) {\r\n                    previous = current\r\n                    current = current.next\r\n                }\r\n                   \r\n                previous.next = current.next\r\n            }\r\n            this.count--\r\n            return current.element // 返回删除的值\r\n\r\n        }\r\n        return undefined // 越界返回undefind,空链表返回undefind\r\n    }\r\n\r\n    getElementAt (index) {\r\n\r\n        if(index >= 0 && index <this.count) { \r\n            let current = this.head\r\n                for(let i = 0 ; i<index ; i++){  \r\n                    current = current.next\r\n                return current\r\n            }\r\n        }\r\n        return undefined\r\n    }\r\n\r\n    // 重写removeAt\r\n    newremoveAt (index) {\r\n        if (index >= 0 && index < this.count) { // 已经排除count==0了\r\n            let current = this.head\r\n          \r\n            if(index===0) { // \r\n                if (this.count == 1 ){\r\n                    this.head = null\r\n                }else {\r\n                    this.head = this.head.next\r\n                }\r\n                // return head.element // 多余\r\n                // 40-44 可合并为 this.head = current.next \r\n            }else{\r\n                const previous = this.getElementAt(index - 1)\r\n                current = previous.next\r\n                previous.next = current.next\r\n                \r\n            }\r\n            this.count--\r\n            return current.element // 返回删除的值\r\n\r\n        }\r\n        return undefined // 越界返回undefind,空链表返回undefind\r\n    }\r\n  \r\n    toString (){\r\n        if (this.head == null) {\r\n            return undefined\r\n        }\r\n        let current = this.head\r\n        let objString = ``  // 用一个空字符串作为累积容器\r\n        for(let i =0 ;i < this.count ; i++){\r\n            objString = `${objString} ${current.element}` // 模版字符串可以实现字符串自增\r\n            current = current.next\r\n        }\r\n\r\n        return objString\r\n    }\r\n\r\n    insert(element , index) {\r\n\r\n        if(index === 0 ){  // 头部操作\r\n          let old_head = this.head\r\n          let node = new Node(element) \r\n          this.head = node\r\n          this.head.next = old_head\r\n\r\n          return true  \r\n        }else if(index > 0 && index <=this.count) {  \r\n            if(index === this.count){   // 尾部操作\r\n                let node = new Node(element) \r\n                let tail = this.getElementAt(this.count-1)\r\n                tail.next = node\r\n            }else{   // 中间段操作\r\n                   let node = new Node(element) \r\n                   let index_node = this.getElementAt(index)\r\n                   let previous_node = this.getElementAt(index-1)\r\n                   previous_node.next = node\r\n                   node.next = index_node\r\n            }\r\n                 \r\n          return true  \r\n        }else{\r\n            return false  // 链表为空\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n","export class Node {\r\n \r\n    constructor (element) {\r\n        this.element = element\r\n        this.next = undefined\r\n    }\r\n\r\n}","export function defaultEquals (a, b) {\r\n    return a===b\r\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import {LinkedList} from '../linklist/LinkedList'\r\n\r\n\r\nlet aa = new LinkedList()\r\naa.push(10)\r\naa.insert(20,1)\r\naa.insert(30,2)\r\n\r\nconsole.log(aa.toString())\r\n"],"names":[],"sourceRoot":""}